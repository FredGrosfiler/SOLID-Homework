package com.grosfiler;

public class Main {

    public static void main(String[] args) {

        String targetName = "Sarah Connor";
        iColdWeapon currentWeapon = new ColdWeapon();

        Terminator t800 = new Terminator("Sarah Connor", currentWeapon);
    }
}

/*
Принцип единственной ответственности (SRP)
Данный принцип гласит: никогда не должно быть больше одной причины изменить класс.

Терминатору в прошлом надо слится с толпой, найти и убить Сару Коннор.
Поведение терминатора может измениться по нескольким причинам. Например может измениться логика маскировки,
алгоритм поиска цели, или способ устранения цели.

Принцип единственной обязанности подразумевает, что все аспекты этой проблемы на самом деле — разные обязанности.
А значит, должны находиться в разных классах или модулях. Объединение нескольких сущностей,
которые могут меняться в разное время и по разным причинам, считается плохим проектным решением.

Принцип открытости/закрытости (OCP)
программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.
Следуя этому принципу, классы разрабатываются так, чтобы для подстройки класса к конкретным условиям применения
было достаточно расширить его и переопределить некоторые функции.
Продолжая пример с Терминатором, предположим, что нам нужно достать одежду для маскировки.
Вместо того, чтобы менять сам класс BlendInModule, мы расширим его и добьемся решения поставленной задачи,
не нарушая принцип OCP.

Принцип подстановки Барбары Лисков (LSP)
объекты в программе можно заменить их наследниками без изменения свойств программы.
Класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так,
чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет класс и
использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов.

В нашем примере если заменить класс ColdWeapon на Firearm при терминации, Терминатор всеравно сможет ударить огнестрелом

Принцип разделения интерфейса (ISP)
клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.
слишком «толстые» интерфейсы необходимо разделять на более мелкие и специфические, чтобы клиенты мелких интерфейсов
знали только о методах, необходимых в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты,
которые этот метод не используют.

В нашем примере Терминатор можно послать не только для убийства Сары Коннор но и например для уничтожения
какого-то стратегичекского обьекта. Для этот TargetTracker может реализовывать оин из двух интерфейсов.

Принцип инверсии зависимостей (DIP)
зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

В данном примере TerminationProcessor зависит от конкретного класса ColdWeapon.
Этот класс далек от того, чтобы называться абстракцией. И с точки зрения принципа DIP было бы правильнее для начала
создать некоторую абстракцию, которая позволит нам оперировать в дальнейшем ей, а не конкретной реализацией.
Создадим интерфейсы iColdWeapon и iFirearm.

Мы провели подготовительную работу, чтобы наш класс TerminationProcessor зависил не от конкретных деталей, а от абстракций.
Внесем в него изменения, внедряя зависимость в конструкторе класса.


Теперь наш класс зависит от абстракций, а не от конкретных реализаций.
Можно без труда менять его поведение, внедряя нужную зависимость в момент создания экземпляра TerminationProcessor.

*/


